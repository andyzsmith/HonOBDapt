<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>HonOBDapt 1</TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.4  (Unix)">
	<META NAME="AUTHOR" CONTENT=" ">
	<META NAME="CREATED" CONTENT="20130621;12200000">
	<META NAME="CHANGED" CONTENT="20130621;12340000">
	<STYLE TYPE="text/css">
	<!--
		@page { margin-right: 1.25in; margin-top: 1in; margin-bottom: 1in }
		P { margin-bottom: 0in; direction: ltr; color: #000000; text-align: left }
		P.western { font-family: "Times New Roman", serif; font-size: 10pt; so-language: en-US }
		P.cjk { font-family: "Times New Roman", serif; font-size: 12pt; so-language: zh-CN }
		P.ctl { font-family: "Times New Roman", serif }
		H1 { margin-top: 0in; margin-bottom: 0in; direction: ltr; color: #000000; text-align: left }
		H1.western { font-family: "Times New Roman", serif; font-size: 16pt; so-language: en-US }
		H1.cjk { font-family: "Times New Roman", serif; font-size: 12pt; so-language: zh-CN }
		H1.ctl { font-family: "Times New Roman", serif; font-size: 12pt }
		H2 { margin-top: 0in; margin-bottom: 0in; direction: ltr; color: #000000; text-align: left }
		H2.western { font-size: 14pt; so-language: en-US; font-weight: normal }
		H2.cjk { font-family: "Times New Roman", serif; font-size: 12pt; so-language: zh-CN; font-weight: normal }
		H2.ctl { font-family: "Times New Roman", serif; font-size: 12pt; font-weight: normal }
		H3 { margin-top: 0in; margin-bottom: 0in; direction: ltr; color: #000000; text-align: left }
		H3.western { so-language: en-US }
		H3.cjk { font-family: "Times New Roman", serif; font-size: 12pt; so-language: zh-CN }
		H3.ctl { font-family: "Times New Roman", serif; font-size: 12pt }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" TEXT="#000000" DIR="LTR" STYLE="border: none; padding: 0in">
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<OL>
	<LI><H1 CLASS="western">HonOBDapt 1.0</H1>
</OL>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=4><B>Intro, Summary</B></FONT></P>
<P CLASS="western"><FONT SIZE=4><B>Prototype</B></FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HonOBDapt translates requests for
on-board automotive computer sensor data from an ISO standard OBD II
format to a Honda proprietary format used in 92-95 Honda Civics.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HonOBDapt uses a general purpose
microcontroller module equipped with external digital I/O ports, the
Arduino Uno Rev. 3.  HonOBDapt uses a Freescale MC33660 ISOLink logic
level converter integrated circuit to electrically connect the OBD II
signal line to the Arduino.  HonOBDapt software is written in C++ and
uses the SoftwareSerialWithHalfDuplex library.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HonOBDapt supports core interactive
diagnostic functionality of the OBD II standard, comprised of
essential sensor data including: air and coolant temperature, spark
advance, fuel injector pulse width, exhaust gas oxygen content,
engine speed (RPM), short and long term fuel trim, fuel system status
(open or closed loop), manifold barometric pressure, atmospheric
barometric pressure, throttle position, vehicle speed, etc.  There is
also a basic capability of translating check engine diagnostic
trouble codes (DTCs).  There is no support for obtaining OBD II
freeze frame data, nor any analog to the concept of continuous fuel
status, EVAP system or misfire monitoring.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>These limitations notwithstanding
this adapter serves a crucial purpose in allowing 92-95 Honda Civics
to be diagnosed with modern, readily available OBD II diagnostic
scanners.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>A prototype was constructed with the
following: several trips to the junkyard to buy a Honda on board
computer (ECU) and OBD II standard connectors, lots of hot glue and
some mild eyestrain from trying to solder the MC33660, which is
manufactured only in a package intended for automated assembly.  The
prototype was tested with an ELM compatible Bluetooth OBD II scanner.
 The prototype was tested with the OBD II PC software packages
Scantool and OBDAutoDoctor.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=4><B>Sections I, II, III: C++ Software
Specification</B></FONT></P>
<P CLASS="western"><FONT SIZE=4><B>Sections IV, V, VI, VII:
Electrical and Hardware specification</B></FONT></P>
<P CLASS="western"><FONT SIZE=4><B>Section VIII: TODO</B></FONT></P>
<P CLASS="western"><BR>
</P>
<OL>
	<OL>
		<LI><H2 CLASS="western">I. Control Flow</H2>
	</OL>
</OL>
<P CLASS="western"><FONT SIZE=2>	Asynchronous Processing Unit Design</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Main Event Loop</FONT></P>
<P CLASS="western"><FONT SIZE=2>	State controller design,
considerations</FONT></P>
<OL>
	<OL START=2>
		<LI><H2 CLASS="western">II. Class Reference</H2>
	</OL>
</OL>
<P CLASS="western"><FONT SIZE=2>	BusCoordinator</FONT></P>
<P CLASS="western"><FONT SIZE=2>	BusInit</FONT></P>
<P CLASS="western"><FONT SIZE=2>	TryReady</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericBusInitAttempt</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericBusInitComplete</FONT></P>
<P CLASS="western"><FONT SIZE=2>	CommCoordinator</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericCommMessageCollector</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericCommMessageProcessor</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaCommCoordinator</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaCommMessageCollector</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaCommMessageProcessor</FONT></P>
<P CLASS="western"><FONT SIZE=2>	IHandler</FONT></P>
<P CLASS="western"><FONT SIZE=2>	IGenericHandler</FONT></P>
<P CLASS="western"><FONT SIZE=2>	IISOReply</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericISOReply</FONT></P>
<P CLASS="western"><FONT SIZE=2>	GenericHandler</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaHandler</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaPort, ISOPort</FONT></P>
<P CLASS="western"><FONT SIZE=2>	HondaMap, ISOPID</FONT></P>
<P CLASS="western"><FONT SIZE=3>	</FONT></P>
<OL>
	<OL START=3>
		<LI><H2 CLASS="western">III. Patterns and Principles</H2>
	</OL>
</OL>
<P CLASS="western"><FONT SIZE=2>	SubSections a, b, c, d, e, f: Object
Oriented Characteristics	</FONT></P>
<P CLASS="western"><FONT SIZE=2>	SubSections g, h, i, j, k, l, m:
Gang of Four Patterns</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>	Polymorphism</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Loose Coupling, </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>	Separation of Concerns</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Information Hiding and Encapsulation</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Reuse and Inheritance</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Generalization</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Template</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Command Pattern</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Chain of Responsibility,
Responsibility Driven Design</FONT></P>
<P CLASS="western"><FONT SIZE=2>	State, Automaton, finite state
machine</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Strategy</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Mediator</FONT></P>
<P CLASS="western"><FONT SIZE=2>	Adapter</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=4>IV. Serial Ports</FONT></P>
<P CLASS="western"><FONT SIZE=4>V. MC33660</FONT></P>
<P CLASS="western"><FONT SIZE=4>VI. Arduino</FONT></P>
<P CLASS="western"><FONT SIZE=4>VII. OBD II</FONT></P>
<P CLASS="western"><FONT SIZE=4>VIII. TODO</FONT></P>
<P CLASS="western"><FONT SIZE=3>	</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<OL>
	<OL>
		<OL>
			<LI><H3 CLASS="western">CONTROL FLOW</H3>
		</OL>
	</OL>
</OL>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Asynchronous processing unit design</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">Generally, classes involved in handshaking and
serial communications support Work(), DoneWorking() and Reset().</P>
<P CLASS="western"><FONT SIZE=2>These functions serve as a basic
cooperative multitasking system.  Work() is called when a higher
level controller has a time slice to give to the unit.  The Work()
function of each controller is expected to do its' work, and exit
quickly.  If the conditions are met that allow the handshaking or
communications to proceed to the next higher level, DoneWorking()
should return true.  Reset() is used to reset the internal state of
the unit, typically at the end of a logical session controlled by a
higher level controller.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Generally, the units are one-shot
triggers.  If, for example, a unit is falsely triggered to initiate a
particular process ( by noise or an invalid packet ), it will
continue to attempt completion of the process and cannot properly
proceed with a valid sequence until it is Reset() by a higher level
controller.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Main Event Loop</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop cycles through
the upper lever coordinators, BusCoordinator, CommCoordinator and
HondaCommCoordinator in a round robin fashion, calling .Work() and
checking .DoneWorking() on each one.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The OBD II port requires a bus
initialization handshaking sequences.  No bus initialization is
necessary on the HondaPort.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop strives to move
the system into higher and higher levels of functioning.  The macro
levels of functioning are:</FONT></P>
<P CLASS="western"><FONT SIZE=2>Level 1. OBD II bus not initialized</FONT></P>
<P CLASS="western"><FONT SIZE=2>Level 2. OBD II bus initialized,
waiting for incoming request from the OBD II port.</FONT></P>
<P CLASS="western"><FONT SIZE=2>Level 3. Message received from the
OBD II port and forwarded to the HondaPort, waiting for message from
HondaPort</FONT></P>
<P CLASS="western"><FONT SIZE=2>Level 4. Message received from the
HondaPort and forwarded to the OBD II port.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Once the functioning level reaches 4,
the process restarts generally at level 2, but possibly level 1.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Level 1.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop maintains a state
variable that is either NO_COMM or COMM_ESTAB.  Each time through the
main event loop, if the state is NO_COMM (bus not initialized), then
BusCoordinator.Work() is called.  </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>The BusCoordinator will work to
initialize the OBD II bus and achieve a higher state, COMM_ESTAB, by
using TryReady, BusInit, GenericBusInitAttempt and
GenericBusInitComplete.  After the call to BusCoordinator.Work(),
BusCoordinator.DoneWorking() is checked.  If this function returns
true, then the bus is ready for communications and the state is set
to COMM_ESTAB. if DoneWorking() is not true, the main event loop
restarts, again attempting to raise the functioning level by
successfully initializating the OBD II bus.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Level 2.</FONT></P>
<P CLASS="western"><FONT SIZE=2>Once the bus is initialized,
CommCoordinator.Work() will be called to try to continue to raise the
processing level.</FONT></P>
<P CLASS="western"><FONT SIZE=2>CommCoordinator will use
GenericCommMessageCollector to get any incoming data on the OBD II
port.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>If there is no data available
immediately on the serial port, the
GenericCommMessageCollector.Work() will exit immediately; this allows
the CommCoordinator to exit and yield control to the main event loop.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>If there is waiting data, the data
will be retrieved and a state of COLLECT will be marked internally to
GenericCommMessageCollector.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>During the next iteration through the
main event loop, CommCoordinator.Work() will be called and the Work()
function will call GenericCommMessageCollector.Work().  If there is
more data available on the OBD II port, that data will be collected
by the GenericCommMessageCollector.  Since the internal state of
GenericCommMessageCollector is COLLECT, the new data will be appended
to the existing message buffer.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Level 3</FONT></P>
<P CLASS="western"><FONT SIZE=2>A true return value from
GenericCommMessageCollector.DoneWorking() signifies that a complete
and valid OBD II message has been received and the internal state of
the coordinator, CommCoordinator, will be marked as MESSAGE_RECEIVED.
 Then the GenericCommMessageProcessor will become active, processing
the request by calling HondaHandler.IncomingPID().  The HondaHandler
will translate the OBD II PID to an appropriate request for Honda
data and will call SendHondaRequest() to send a command sequence to
the HondaPort.  HondaHandler will then assign the request to the
HondaCommCoordinator, which queues the request, using a function
pointer to establish a non-blocking asynchronous callback to be
executed when the HondaPort data is ready.</FONT></P>
<P CLASS="western"><FONT SIZE=2>CommMessageProcessor and
CommCoordinator then yield control to the main event loop.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>During the next iteration of the main
event loop, HondaCommCoordinator.Work() will be called and the
HondaCommCoordinator will pick up the queued request and set an
internal state of WORKING.  The HondaCommCoordinator will use the
HondaCommMessageCollector to get any incoming data on the HondaPort. 
If there is waiting data, the character data will be retrieved and a
state of COLLECT will be marked internally in the
HondaCommMessageCollector</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>DUring the next iteration through the
main event loop, HondaCommCoordinator.Work() will be called.  If
there is more data, that data will be collected by the
HondaCommMessageCollector.  Since the internal state of
HondaCommMessageCollector is COLLECT the new data will be appended to
the existing message buffer.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Level 4</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>When the message from the HondaPort
is complete and valid, signaled by the HondaCommMessageCollector
returning true to DoneWorking(), the HondaCommMessageProcessor will
become active and process the message by executing
HondaHandler.Callback().  HondaHandler.Callback() will execute the
appropriate return function matching the original asynchronous
request and effect the translation of the Honda sensor data into ISO
measurements, using a member of the group ISOMeasurementsTOISOReply,
and the reply to the OBD II port, using a GenericHandler.IISOReply
family member.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>At this point the overall state has
reached its highest point of productivity.  The various
MessageCollector(s) and MessageProcessor(s) are reset, and the main
event loop restarts at level 2, waiting for more serial messages from
the OBD II port.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>-- Advantages of state controller
design</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>---Extensibility</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>This structure provides a clean,
clear implementation that lends itself to further modifications and
extension, such as hooks to process other data or timeout watchdogs,
because there are clear places to hook into the overall flow of
handshaking or messaging without the risk of undesirable interaction
or needing to understand the lower level operation of each
controller.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>This structure also provides a clean
way to implement potentially deep nested logic in a clear, easy to
debug and trace fashion.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Each asynchronous unit is coded with
the overall structure in mind.  For example, TryReady.Work() will not
block but will do a small amount of work, polling the OBD II K-Line
bus status and checking the time-of-day ( millis() ) to maintain a
running total of idle time and then Work() will exit.  TryReady can
maintain internal state such as the running total but encapsulates
that state and signifies that internal conditions have been satisfied
by returning true to DoneWorking().  Also, when logical conditions
require, Reset() can be used to reset the running total.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>In this way serial communications or
handshaking can be carefully controlled from the upper level.  </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>For instance, this structure makes it
easy and clear to implement an *OVERALL* handshake attempt timeout,
without modifying functionally distinct units such as TryReady.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>---Error Handling</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>When dealing with serial port
messaging, subject to noise, message fragments being received, etc, </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>it is quite possible for individual
functional units to become stuck or hung due to: waiting for message
termination or validation that will never succeed because of
mid-message corruption, invalid or nonstandard messages, etc.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>In this type of messaging environment
it is important to maintain supervisory control with clear top-down
control logic.  The asynchronous, non-blocking Work(), DoneWorking()
pattern lends itself to implementing supervisory controls.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Of paramount importance is that the
supervisory code and its' interface to lower level code be clear,
distinct and concise, so that unforseen situations; i.e. dealing with
slightly altered or new packets or protocol details and their
concomitant issues; can be dealt with effectively.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>---Complexity and correctness</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The factoring of complicated nested
communications logic into a body of state machines is an effective
way of managing complexity and makes logical defects more apparent. 
This factoring methodology allows the program to be treated as the
steps of an algorithm, facilitating the application of mathematically
rigorous techniques to prove or disprove the correctness of the
program logic.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>-- Possible ramifications of state
controller design</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Although the event loop design of the
serial communications code has additional overhead compared to a more
direct low-level approach, and can cause an entire event loop to be
executed between individual serial character data retrievals, the
overhead is mostly syntactic exposition, and is not expected to be
computationally intensive.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">As well, 9600 baud is not particularly fast
relative to Arduino's microprocessor speed and the SoftwareSerial
library is interrupt driven ( interrupts take priority over all other
execution context ) and SoftwareSerial maintains its' own input
buffers.  Also, the direct serial controllers, CommMessageCollector
and HondaCommMessageCollector are enhanced with a burst mode that
increases their priority under certain circumstances.  Due to these
factors it is considered extremely unlikely for the overhead of the
state machine control system to cause a loss of serial data on any
port.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>CLASS REFERENCE</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>BusCoordinator</FONT></P>
<P CLASS="western"><FONT SIZE=2>The BusCoordinator is responsible for
coordinating the bus initialization process including: bus idle time
prerequisite, wakeup-packet handshaking and confirmation handshaking.</FONT></P>
<P CLASS="western"><FONT SIZE=2>The Buscoordinator uses TryReady,
BusInit, GenericBusInitAttempt, and GenericBusInitComplete.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>TryReady</FONT></P>
<P CLASS="western">TryReady polls the OBD II K-Line bus pin and
establishes that the necessary bus idle condition has been met before
handshaking begins.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>BusInit</FONT></P>
<P CLASS="western">Tasked with the job of attempting and completing
an OBD II bus initialization handshake sequence.  Uses
GenericBusInitAttempt and GenericBusInitComplete.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericBusInitAttempt â€“ </FONT>
</P>
<P CLASS="western">establishes generic requirements for a bus
initialization attempt, which begins the handshaking sequence of an
OBD II session.  Uses WAKE_PACK array, a storage area for K-Line bus
pin logic level transition times ( 10ms, 100ms, etc ).  This routine
uses Arduino's digitalRead to check the logic level of the OBD II
K-Line bus pin.  When the pin alters state ( High to Low or Low to
High ) the time-of-day ( millis() ) is recorded.  This recorded value
is compared to the time-of-day when the next level transition occurs,
and in this way the length of the handshaking pulse or pulses is
established.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>If the transition pattern is a valid
OBD II K-Line bus wake-up pattern, DoneWorking() will return true.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The protocol specific details of the
GenericBusInitAttempt are left to the more derived classes</FONT></P>
<P CLASS="western"><FONT SIZE=2>BusInitAttempt_ISO14230_slow,
BusInitAttempt_ISO14230_fast, BusInitAttempt_ISO9141</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericBusInitComplete </FONT>
</P>
<P CLASS="western">establishes basic requirements of bus
initialization completion which finishes the handshaking sequences
for an OBD II session.  The completion of the handshaking is
accomplished by sending a confirmation message,  mathematically
derived from the messages received during a bus initialization
attempt, to the OBD II port.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The protocol specific details of the
BusInitComplete are left to the more derived classes: </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>BusInitComplete_ISO9141,
BusInitComplete_14230_slow, BusInitComplete_ISO14230_fast</FONT></P>
<P CLASS="western"> 
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>CommCoordinator </FONT>
</P>
<P CLASS="western">The CommCoordinator is responsible for collecting,
verifying and processing messages on the OBD II K-line serial port. 
Processing generally concludes with a call to
HondaHandler.IncomingPID(), which accepts responsibility for replying
to the OBD II K-line serial port with the requested Honda on board
computer (ECU) data.  Uses GenericCommMessageCollector and
GenericCommMessageProcessor.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericCommMessageCollector </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>Collects the serial data from the OBD
II port and establishes completeness (appropriate headers) and basic
error-checking (checksum) of incoming serial data.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">This message collector supports a serial burst
mode, assuming that an incoming serial character is usually followed
by the remaining characters without delay.  This routine is
authorized to busy-wait (block) waiting for serial data for a maximum
time interval defined by SERIAL_BURST_MAX_TIME_SLICE, before
relinquishing control to its' coordinator.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Protocol specific details are left to
the more derived classes: ISOCommMessageCollector_ISO9141,
ISOCommMessageCollector_ISO14230</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericCommMessageProcessor - </FONT>
</P>
<P CLASS="western">Processes a valid message containing an OBD II PID
by calling HondaHandler.IncomingPID() to transfer responsibility for
retrieving the requested data and sending a reply to the OBD II port.
 IncomingPID function does not block and GenericCommMessageProcessor
and its' coordinator CommCoordinator can exit immediately after the
call to IncomingPID.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Protocol specific details are left to
the more derived classes: CommMessageProcessor_ISO9141,
CommMessageProcessor_ISO14230</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HondaCommCoordinator </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>manages Honda communications.  Uses
HondaCommMessageCollector and HondaCommMessageProcessor.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Works in conjunction with the
HondaHandler.  Provides AssignWork function which, when called by
HondaHandler, queues a request for Honda data.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HondaCommMessageCollector</FONT></P>
<P CLASS="western">Collects the serial data from the HondaPort. 
Establishes completeness, appropriate headers, error-checking
(checksum) of incoming serial data.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>This message collector supports a
serial burst mode, assuming that an incoming serial character is
usually followed by the remaining characters without delay.  This
routine is authorized to busy-wait (block) waiting for serial data
for a maximum time interval defined by SERIAL_BURST_MAX_TIME_SLICE,
before relinquishing control to its' coordinator.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HondaCommMessageProcessor</FONT></P>
<P CLASS="western">Processes valid messages from the HondaPort. 
Processing concludes with a call to HondaHandler.Callback(), which
effects translation of the Honda data and the reply to the OBD II
port using a member of the GenericHandler ISOMeasurementsToISOReply
group and an IISOReply family member.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>IHandler </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>establishes what a handler, used by
the CommCoordinator.CommMessageProcessor, must do</FONT></P>
<P CLASS="western"><FONT SIZE=2>A class implementing IHandler must
support IncomingPID.  At a fundamental level, to implement the
IHandler interface the class must be able to do something with
IncomingPID, perhaps ignoring unsupported operations.  This class
would be a good jumping off point for diverse purposes, for example,
a class that only logs the incoming messages.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>IGenericHandler </FONT>
</P>
<P CLASS="western">supports VIN and Capabilities.</P>
<P CLASS="western">A slightly richer implementation would be required
to, at a minimum, reply with the Vehicle Identification Number and
the Capabilities, which is a list of supported sensors or other data
that can be retrieved.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>IISOReply </FONT>
</P>
<P CLASS="western">is an interface defining the generic requirements
of a reply to the OBD II port.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericISOReply </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>is class containing generic OBD II
port reply code.  </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>The protocol specific details are
left to the more derived classes: ProtocolReply_ISO9141 and
ProtocolReply_ISO14230.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>GenericHandler</FONT></P>
<P CLASS="western"><FONT SIZE=2>Adds an interface of virtual function
prototypes that describe the expected input and output for a sensor
data retrieval implementation and a baseline map function,
ISOPID_TO_GENERIC_HANDLER_MAP, that links OBD II PIDs to functions in
the sensor interface.  GenericHandler builds directly upon its direct
ancestor abstractions IGenericHandler and IHandler, but becomes
richer and more concrete by extending outside of that family to
become a composition with an IISOReply family member.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">GenericHandler also defines functions that convert
data to an OBD II format.  These functions follow the naming
convention ISOMeasurementsToISOReply..XXXXX.  These functions accept
input data in the scale dictated by the OBD II standard; i.e.
temperature is measured in Celcius degress, with the input data to
the function represented by the formula &quot;Actual Temp - 40&quot;.
 E.G., if the temperature of the coolant is determined to be 55 deg.
C., you would call ISOMeasureToISOReply_Scalar_byte( 15 );</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The inclusion of an IISOReply family
member which includes functions that reply to the OBD II port and the
definitions of the ISOMeasurementsToISOReply functions establishes
that at this level of class abstraction that the concept of handling
will be to send a reply message to the OBD II port.  The IISOReply
member also provides functions toward this end.  At this level, the
implementation of the sensor data virtual functions is left abstract.
 </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HondaHandler </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>becomes the most derived, richest
member of this family tree.  It is a complete, fully functional
handler.  It adds concrete implementations of the remaining
abstractions in the GenericHandler family hierarchy, the abstract
sensor data retrieval interface and IncomingPID().  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The HondaHandler implements
IncomingPID by using the generic mapping of OBD II PIDS onto the
abstract sensor data retrieval interface,
ISOPID_TO_GENERIC_HANDLER_MAP.  The HondaHandler implementation of
the sensor data retrieval functions is asynchronous, and delegated,
relying on the placement of its' functional colleague,
HondaCommCoordinator, in the main event loop, to retrieve the data
from the HondaPort.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaCommCoordinator.AssignWork() is
used to communicate with the HondaCommCoordinator, requesting that
during the next main event loop cycle, the retrieval of a particular
sensor value from the Honda on board computer (ECU).</FONT></P>
<P CLASS="western"><FONT SIZE=2>AssignWork establishes a callback
function pointer for the HondaCommCoordinator to call when the
requested data has been retrieved.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>When the HondaCommCoordinator
responds with the data, HondaHandler converts, maps or otherwise
translates the data values from the Honda scaling or other
representations, into values compatible with the OBD II measurement
scale or representation.  Then a member of the
GenericHandler.ISOMeasurementsTOISOReply...XXXX group is called to
generically convert the data into an OBD II format and then use an
IISOReply family member to effect the reply to the OBD II port using
the proper protocol.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaHandler implements the
IGeneralAsyncHandler interface, marking it as an asynchronous class.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaHandler defines
GeneralAsyncRequest, a function that factors out the common code for
setting up the function pointer.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>IGenericAsyncHandler </FONT>
</P>
<P CLASS="western">IGenericAsyncHandler is a marker interface. 
Implementing it marks a class as asynchronous in nature.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>ISOPort, HondaPort</FONT></P>
<P CLASS="western"><FONT SIZE=2>ISOPort and HondaPort provide
character based access to the serial ports, defined using a
SoftwareSerial instance configured to communicate on the digital I/O
pins connected to the OBD II connector and the Honda Diagnostic Link
Connector.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>ISOPort and HondaPort provide safety
features by providing a consistent interface to the serial ports,
which can often become unmanageable within nested serial
communications logic.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>All reads and writes are done through
these interfaces, so the checksums are calculated through these
routines, reducing the risk of multiple conflicting direct access.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>HondaMap </FONT>
</P>
<P CLASS="western">HondaMap objects are used to refer to specific
sensors in the Honda on-board computer (ECU).  The definition
includes an address and length.  Some sensors return two bytes, for
example, RPM.  If the two-byte return data is a scalar value, the
data is big-endian, that is, the most significant byte, the one that
counts for 256 for each 1 of its' value, is the first of the
two-bytes transmitted by the ECU.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>ISOPID</FONT></P>
<P CLASS="western">ISOPID objects are used to represent OBD II
requests.  Each request contains a mode and an identifier.  Mode 1 is
sensors.  Mode 3 is Diagnostic Trouble Codes. E.G. Mode 1, identifier
0x0C is engine speed (RPM).</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>PATTERNS</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Object Oriented characteristics:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Polymorphism</FONT></P>
<P CLASS="western"><FONT SIZE=2>GenericBusInitAttempt,
ISO14230_BusInitAttempt, ISO9141_BusInitAttempt</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>When the variable oBusInitAttempt
takes the form of a ISO14230_BusInitAttempt, the BusCoordinator
doesn't know or care about this.  All the BusCoordinator needs to
know is that a GenericBusInitAttempt is being utilized.  Thus the
principle of polymorphism, or many forms, is being leveraged to
achieve more generalized code.  From one perspective the form of the
instance variable oBusInitAttempt is GenericBusInitAttempt and from
another perspective the form is ISO14230_BusInitAttempt, thus
polymorphic.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>IHandler, GenericHandler,
HondaHandler</FONT></P>
<P CLASS="western">The IHandler abstract interface is used in the
CommMessageProcessor.  The form of the instance variable in
CommMessageProcessor is an abstract IHandler at compile time.  At run
time, however the IHandler object takes the form of a concrete
HondaHandler.  From the perspective of the CommMessageProcessor the
instance variable is an IHandler, but from a macro, system level
view, the instance variable is a HondaHandler.  Thus this variable
takes many forms and is polymorphic.  GenericHandler is another form
of an IHandler, albeit a kind of abstract 'unexpressed' form, as
instantiating it would result in an incomplete handler
implementation.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Loose Coupling</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Even though they work closely
together to accomplish the overall goal in this adapter
implementation, </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>there is a loose-coupling between the
CommMessageProcessor, receiving a PID from the OBDII port and the
HondaHandler, effecting a reply to the OBD II port.  This coupling is
loose because the Handler could be implemented in different ways and
this loose coupling leaves the door open for more diverse
interpretations of the term 'handling'.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>In this adapter implementation the
loose coupling make it easier to inject an asynchronous handler into
the design.  The CommMessageProcessor is coupled only to an IHandler,
an interface definition ( aka, contract specification ), not tied
directly to the asynchronous implementation of HondaHandler, reducing
the chance of cascading changes rippling through multiple functional
units.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>One of the advantages of the loose
coupling in this adapter implementation is its' ability to mitigate
the situation where one subsystem is blocked by another.  It would be
undesirable to make the CommMessageProcessor block(wait) for the
Honda data to be retrieved. The data may never come but we still want
the CommMessageProcessor to be able to degrade gracefully and respond
to its' immediate supervisor.  The loose coupling supports this
because the HondaHandler doesn't take control when it is tasked with
getting Honda sensor data.  It is delegated to do so and this is a
pattern of Chain of Responsibility, but the CommMessageProcessor
maintains control and can exit cleanly.  This clean exit facilitates
the placement of supervisory control logic where it belongs; at a
high logical level in the code, not buried deep in the implementation
details of a particular low level unit.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Loose coupling has its benefits and
downfalls.  Loose coupling allows flexibility in implementing the
Handler without changing the CommMessageProcessor, and ultimately
aids in the implementation of an asynchronous handler, but this does
not come without issues.  For example, there is no way to easily
enforce transactional integrity across this coupling, or pass error
or control messages such as 'retry' across this coupling because by
the time a failure is detected on one side of the coupling, the
execution context that initiated the request has exited.  A similar
problem occurs with non-asynchronous loose coupling, where, for
example, it is impossible to pass an error message because the loose
coupling only supports a limited interface.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Separation of Concerns</FONT></P>
<P CLASS="western"><FONT SIZE=3>See _Patterns and Principles_ &quot;Loose
Coupling&quot;, &quot;Information Hiding and Encapsulation&quot;, and
&quot;Chain of Responsibility&quot;</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Generalization</FONT></P>
<P CLASS="western"><FONT SIZE=3>-- Reuse, Inheritance and Templates</FONT></P>
<P CLASS="western"><FONT SIZE=3>--- Benefits</FONT></P>
<P CLASS="western">The sharing of common functionality reduces the
overall code load that must be inspected.  It also increase the
chances that changes made to the system will propagate in the proper
way.</P>
<P CLASS="western"><FONT SIZE=3>--- Ramifications		  </FONT>
</P>
<P CLASS="western">The factoring out of common functionality must be
done thoughtfully and carefully, as the benefits of reuse 		are
quickly outweighed by the complexity of managing entanglement between
sharing classes.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>See Also, Generalization,
composition, flexibility of modularity</FONT></P>
<P CLASS="western"><FONT SIZE=3>see Also, Generalization,
composition, ramifications</FONT></P>
<P CLASS="western"><FONT SIZE=3>See Also, Generalization,
overgeneralization</FONT></P>
<P CLASS="western"><FONT SIZE=3>See Also, Template for examples;
Generally whereever there is a Template there is reuse.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Generalization, composition</FONT></P>
<P CLASS="western"><FONT SIZE=3>-- Reuse, factoring, flexibility of
modularity</FONT></P>
<P CLASS="western"><FONT SIZE=3>--- Benefits</FONT></P>
<P CLASS="western"><FONT SIZE=2>Factoring out distinct conceptual
groups of functionality like sensor data virtual function interface,
	ISOMeasurementsTOISOReply grouping, IISOReply and GenericISOReply
provides the flexibility of modularity.  		Individual pieces can be
swapped in and out, e.g. substituting a newer Controller Area Network
diagnostic 	subsystem implementation for the OBD II system, as long
as the new piece adheres to the established 		convention, defined by
interfaces.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Flexibilty means less risk. 
Generalizing may take more front-end design time, but reduces the
amplitude of wild-schedule swings on the back end.</FONT></P>
<P CLASS="western"><FONT SIZE=3>--- Ramifications</FONT></P>
<P CLASS="western"><FONT SIZE=2>Compositional reuse can lead a design
down a dead end.  If a class inherits everything from a composed
class and implements a new subsystem, without a solid set of abstract
interfaces ( or contracts ) to define exactly where in the tree the
new functionality branches off from ( or differs from the previous
incarnation ), it is likely that new functionality will simply
rewrite existing functionality.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>So there is a place on the spectrum
between strict inheritance hierarchy-to-god class compositional
multipurposing that must be chosen carefully.  Too tight interface
adherence limits the diversity that future implementations can
create.  Too little interface adherance and excessive use of ad-hoc
compositional reuse encourages rewrites and big-ball-of-mud designs.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Overgeneralization</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">The attempt to use generic structures is a noble
goal, but there is a limit to how far to take it.  The architect of
class families must focus on the real purpose of the design effort. 
Is it to solve a particular problem, with a flexible building block
pattern, that reduces the risk that changing requirements will render
the code unusable?  
</P>
<P CLASS="western"><FONT SIZE=2>Or is the design effort moving
dangerously toward overgeneralization.  For example, a good home
builder might carry a variety of tools, saws, hammer, etc, some of
which may even be used to build other tools. e.g. scaffolding for
painting.  But the home builder doesn't carry a smelting forge in the
truck.  He doesn't need that much generality and to attempt such
would actually be counterproductive - for building a house - so the
principle is to keep some perspective about the goal you are trying
to achieve.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Too much factoring and generalizing
can cause unnecessary complexity.  As the class family becomes more
fragmented and modular it becomes harder for the consumer to
understand how to use it.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>So the place on the spectrum of
generalism-to-specialization is important.  There is always a design
trade-off.  As Spolsky says, the trash can must be open on top so
people can put trash in.  But it needs to be closed on top so trash
doesn't blow away.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Generalization, practical
implications and best practices</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The structure of the IHandler family,
beginning with the IHandler interface and ending with the
HondaHandler.</FONT></P>
<P CLASS="western"><FONT SIZE=2>is constructed with inheritance and
composition.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The HondaHandler inherits
functionality from the trunk, GenericHandler.  But GenericHandler is
actually formed of inheritance from IGenericHandler and IHandler, but
also of composition with another family tree, IISOReply.  So the
trunk HondaHandler inherits is already a compositional mixture and
not a strict inheritance hierarchy of 'is a' relationships.  The
mixing of the ISOMeasurementsTOISOReply functions and an IISOReply
family member into the IHandler family hierarchy effectively
constrains handlers derived from GenericHandler to being OBD II-based
handlers.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaHandler is also formed with a
mix of inheritance and composition; inheriting from GenericHandler
but also formed by being composed with IGenericAsyncHandler.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>In principle, if the classes form a
definite tight hierarchy and really could not be split into separate
pieces that are independently functional, use inheritance.  Another
rule of thumb is if the relationship is a direct building *upon* ,
use inheritance.  If the relationship is a kind of association with,
or equal level partnership, use composition.  If the classes could be
split, use a composition approach to achieve the right mix of
'lateral' building blocks.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The GenericHandler is made concrete
on the OBD II side and left abstract on the Honda side because this
is the most likely usage pattern.  The next logical step for the
IHandler family tree would be to branch off at the GenericHandler
level to create a concrete implementation of another proprietary
standard that needed to adapt to the now ubiquitious OBD II standard.
 This is a likely re-use pattern, but not the only one afforded by
the generalization topology described here.  It is hard to
conceptualize exactly what could be constructed with the existing
modules and interfaces ( or contracts ) but that is the beauty of
infrastructure in the designer's opinion.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">Generalization principles serve as design
heuristics when building re-usable infrastructure ( or tooling ) to
build Mediators like GenericHandler where one or more sides may be
unknown at the time of construction of the tooling.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Mixins</FONT></P>
<P CLASS="western">The IHandler family may benefit from a more formal
analysis and re-design using mixins, which are a combination of
methods from separate classes.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Traits</FONT></P>
<P CLASS="western">The IHandler family may benefit from a more formal
analysis and re-design using traits, a set of methods that implement
a behaviour and a set of methods that parameterize that behaviour.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>See Also, _Class References_
&quot;GenericHandler&quot;, &quot;HondaHandler&quot;</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Template:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">IHandler provides a template for any class that
may be used as a handler, by CommMessageProcessor.</P>
<P CLASS="western"><FONT SIZE=2>HondaHandler is the most derived
class from this template.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>IISOReply provides a template for any
class that replies to the ISOPort.  ISOReply_9141 and ISOReply14320
build on this template.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>GenericBusInitAttempt provides a
template for classes that attempt OBD II protocol bus initialization.
 Since there are three similar but nontheless unique possible methods
of initialization (ISO9141, ISO14230_slow, and ISO14230_fast) the
shared code between these three is factored into the template and
only the unique characteristics remain in the most derived classes
(BusInitAttempt_ISO9141, BusInitAttempt_ISO14230_slow,
BusInitAttempt_ISO14230_fast).</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Information Hiding and Encapsulation</FONT></P>
<P CLASS="western"><FONT SIZE=2>ISOPort and HondaPort encapsulate the
checksum running total variable, improving code safety.</FONT></P>
<P CLASS="western"> 
</P>
<P CLASS="western">Each coordinator (BusCoordinator, CommCoordinator,
HondaCommCoordinator) or controller (TryReady, BusInitAttempt,
CommMessageCollector, etc) hides its internal state, providing a
standard interface.  This improves safety and reduces the need to
understand the internal details to make changes to the logic using
these functional units.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaMap and ISOPID classes hide the
low-level details of these data structures, providing a safer ( e.g.
a Honda address can never be inadvertently associated with wrong
length because they are stored together ), more convenient way of
manipulating these logical units.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Command Pattern</FONT></P>
<P CLASS="western">GenericHandler contains a function
ISOPID_TO_GENERIC_HANDLER_MAP(), that is built in a command pattern
that lends itself to further ad-hoc modification by adding executable
code within the respective command hooks.</P>
<P CLASS="western"><FONT SIZE=2>Each ISOPID is treated as a command
object, directing execution into the appropriate sensor data
retrieval function.  This pattern is extensible, for example, easily
allowing for two or more separate retrieval steps or other ad-hoc
functionality in the commanded subroutine.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Chain of Responsibility:</FONT></P>
<P CLASS="western"><FONT SIZE=2>The functional colleagues
CommMessageProcessor and HondaHandler exhibit characteristics of a
Chain of Responsibility pattern.  The CommMessageProcessor does not
directly handle the gathering of the data that is required for the
successful conversions of the PID it receives into Honda data. 
Rather, it relies on an indirect Chain of Responsibility.  When a PID
is received by CommMessageProcessor, a delegating call to IncomingPID
is made.  This shifts responsibility of actually completing this task
onto another subsystem.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>HondaHandler, AssignWork,
GeneralAsyncRequest</FONT></P>
<P CLASS="western"><FONT SIZE=2>The HondaHandler sends a message to
HondaCommCoordinator using AssignWork to retrieve the appropriate
data from the HondaPort.  The AssignWork function shifts the
responsibility to the HondaCommCoordinator to retrieve the data.  The
HondaCommCoordinator is given the responsibility for retrieving the
data, and is also given the tools, in the form of a Callback function
pointer, to *ASYNCHRONOUSLY* satisfy it's obligation of returning the
data.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The BusCoordinator, BusInit and
GenericBusInitAttempt (or GenericBusInitComplete) form a Chain of
Responsibility pattern.  The BusCoordinator is responsible for the
overall bus initialization sequences, but it delegates responsibilty
for this task to two associated classes, TryReady and BusInit. 
BusInit then transfers responsibility to its' delegates
GenericBusInitAttempt and GenericBusInitComplete.  Thus the
responsibility for certain actions is transferred in a chain.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop and select parts
of the class design could be considered an example of Responsibility
Driven Design, using a Clustered/Delegated control Structure.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>State:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Many examples:  </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop stores state
about the overall OBD II connection state with two macro level
states, NO_COMM and COMM_ESTAB.</FONT></P>
<P CLASS="western"><FONT SIZE=2>BusCoordinator stores state about the
state of bus handshaking.  </FONT>
</P>
<P CLASS="western"><FONT SIZE=2>BusInitAttempt stores state about the
state of the bus initialization attempt.</FONT></P>
<P CLASS="western"><FONT SIZE=2>Each of these units is called
repeatedly to accomplish a single logical task and they keep track of
where they are by a State pattern; they are guided and alter their
behaviour based on their transient state.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>DoneWorking() and Reset() provide
consistent, safe, encapsulated access to the state.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The main event loop and all the
subsidiary loops contained within could all be considered an example
of one complex Automaton.  These structures could also be described
as finite state machines.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Strategy:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">The implementation of IHandler.IncomingPID() by
HondaHandler could be considered one Strategy for dealing with the
incoming OBD II request.  This larger unit of work seems to qualify
as a strategy and diverges from the Template definition of mere
alteration of subtle details by a class deriving from a Template.</P>
<P CLASS="western"><FONT SIZE=2>Compare Template.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Mediator:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>GenericHandler is a mediator because
it is the only class that knows the internal details of two systems:
the OBD II system and the Honda system.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>From the perspective of the
CommMessageProcessor, the IHandler base interface presents a
simplified interface to the Honda side that consists of only one
function call, IncomingPID.  </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>From the perspective of the Honda
side GenericHandler presents a simplified interface to the OBD II
side that consists of a group of ISOMeasurementsToISOReply...XXXX
reply functions.  The input and operation of these functions is well
defined and simple.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Thus the GenericHandler serves as a
mediator, providing a simplified interface to a complex task of
obtaining Honda sensor data as well a providing a simplified
interface to a complex task of sending data to the OBD II port using
the proper protocol, mediating these two sides of the system.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Adapter:</FONT></P>
<P CLASS="western">At a macro level, the entire hardware / software
system is an Adapter, converting and translating the requests and
data from one system into a format compatible with another system.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>SERIAL PORTS</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Software Serial</FONT></P>
<P CLASS="western"><FONT SIZE=2>The SoftwareSerial library was chosen
for two reasons.  The Arduino only has one hardware serial port, and
the best use for this port is as a debugging aid to see the trace
messages from the monitor.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The other reason is that there is a
need to operate the serial port at a non-standard Honda baud rate. 
The serial timing in SoftwareSerial.h was adjusted, though minimally,
for 9470 baud.  The original timing for 9600 baud worked before these
adjustments were made.  This baud rate is relatively low and the
difference between the Honda rate and the standard rate is small, so
it is possible these timing adjustments are superfluous.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Due to the nature of the
SoftwareSerial interrupt driven design, only one serial port can be
active at any time.  Therefore, at precise junctions in the control
structure, each port is activated with a .listen() statement.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>Half Duplex. This section is
unconfirmed and based on the best knowledge of the designer.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>SoftwareSerialWithHalfDuplex is used
because the communication line on the Honda Diagnostic Link Connector
is half duplex, that is, only one member, the client (HonOBDapt) or
the server (on board computer, ECU) can transmit data at one time. 
SoftwareSerialWithHalfDuplex supports this configuration by
specifying the same pin for Transmit and Receive.  It is the
responibillty of the HondaCommCoordinator to enforce this constraint,
as the behaviour of SoftwareSerialWithHalfDuplex if an attempt is
made to transmit and receive at the same time is unknown.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">The OBD II ISOPort is also half duplex, but is
connected to the MC33660 which has a full duplex style of connection
with both Receive and Transmit pin connections.  This provides a
physical, electrical way of enforcing half duplex on the OBD II
K-Line, as a communications participant attempting to bring the line
low or high while the other participant is still transmitting will
simply be ignored by the circuitry in the MC33660.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>MC33660</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>MC33660 is a level conversion
integrated circuit that converts 5 volt logic signals to 12 volt
logic signals.  This is necessary because the main hardware
component, the Arduino, uses 5 volt signals on its' digital I/O pins
and OBD II specifies 12 volt signals.  MC33660 is an integrated
circuit specifically designed for logic level conversion in an OBD II
automotive application and should therefore be particularly suited to
this application in terms of susceptibility to noise, overload
protection, etc.  MC33660 is designed to be connected to the K-Line
bus and therefore provides an appropriate electrical interface for
serial communications and bus-style level transitions.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>Arduino</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western">Arduino provides 5 volt logic level digital I/O
pins that are suited to this application.  The application of a
software library that allows serial communications on any pin
provides significant flexibility.  Arduino has flexible power supply
requirements and can be operated on a 12 volt system.  Nominal
current draw through the onboard voltage regulator in this
application is 200mA.  Heat created by the voltage regulator dropping
12 volts to 5 volts to power the on board processor is dissipated by
a small on-board heatsink, so the current limits and supply voltage
combination must be carefully selected.  The current configuration is
within limits to the best knowledge of the designer and has been
anecdotally confirmed by feeling for excess heat from the voltage
regulator.</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>OBD II</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=2>The OBD II electrical and logical
communications standard is actually a conglomeration of many existing
standards at the time of creation of the OBD II 'standard' by ISO. 
This adapter supports the K-Line standard(s) of ISO-9141,
ISO-14230_slow, and ISO-14230_fast.  Only one is technically required
as any OBD II compliant scanner must be able to work with all three,
but the implementations vary only minimally and provide a good
exercise and example of certain software design techniques.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>TODO</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>----Asynchronous Multitasking: </FONT>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>There should be an ITask interface to
constrain and define the exact nature of the controller(s) that have
the Work(), DoneWorking(), and Reset() functions.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>-----Handler class family
construction:</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The sensor data virtual function
prototypes in GenericHandler should be split into a separate
interface definition, then implemented virtually by GenericHandler
and concretely by more derived classes like HondaHandler.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The ISOMeasurementToISOReply...XXXX
family of functions should be extracted out of GenericHandler and put
in a separate mix-in.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The IGeneralAsyncHander should be
expanded and more clearly defined to include the GeneralAsyncRequest
function defined in an ad-hoc manner in HondaHandler.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>----Other</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The HondaCommCoordinator should
implement an IWorkQueue interface, clarifying the role of the
Assignwork function.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><FONT SIZE=3>The magic number(s) of the digital
I/O pins used for serial communications in SoftwareSerial should be
extracted out into a #define.</FONT></P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"><BR>
</P>
<P CLASS="western"> 
</P>
<P CLASS="western"><BR>
</P>
</BODY>
</HTML>